# 北航OO第一单元作业总结

## 前言

第一单元我尽力过了中测，过了中测之后并没有进行更多自测，程序漏洞百出，强测结果相当惨烈。

## 第一次作业

第一次作业公测截止的前一天晚上，我还没通过第九个测试点。本来感觉第一次就要以失败告终，幸运的是第二天开放了第九个测试点，修改了相应的bug后通过了中测。但这件事也对我后续的心态产生影响，开始抱着通过了中测就好的心态完成作业，相应的代价也是惨痛的。

### 题目要求

第一次作业任务是读入一个包含加、减、乘、乘方、一层括号的多变量表达式，要求展开括号，并进行相应的化简提高性能。

### 遇到的困难

可以通过正则表达式或递归下降分析法解决该问题，正则表达式不利于后续迭代，并且我认为处理起来也并不简单，所以果断选择使用递归下降分析法。虽上学期`OOpre`课最后一次作业涉及递归下降分析法，但是第一次作业我却连**最基本的`Parser`和`Lexer`代码都写不出**。直到周五的实验课后，我才大概知道怎么写出`Parser`和`Lexer`。

之后仍是一头雾水，解析出各种因子和项之后，我**不知道之后要干什么，尤其是怎么展开括号**——不知道展开括号其实就是造一堆新项并返回由它们组成的`ArrayList`或`Expr`。即使与同学交流后知道了这一点，我又陷入了诸如“若项里存在多个表达式时，怎么操作啊？是不是要写表达式乘表达式，项乘项等等方法啊？”等一系列困扰中。费劲九牛二虎之力完成基本例子的测试后，公测又错了很多点。这时我又发现了新的问题——**符号保存、改变问题**。因为当时term和每个因子我都设置了符号，我的这种乘法操作中，它们符号总是要变来变去的，难以处理。但根本原因还是在于我对各个类的功能不清楚，不确定用谁来保存符号，乘法后谁改变符号、谁不改变符号，所以即使后来采用了递归展开括号的方法，这个问题还是时常出现，跟随了我整个第一单元。

### 架构设计

就说说让我印象深刻~~饱受折磨~~的几个点：

* 采用递归下降分析法，当`Paser`中`Lexer`读到相应的符号时，跳入解析相应`Factor`或`Term`的`Paser`中的方法并返回相应的实例（若`Term`，则返回一个`ArrayList<Term>`）

* `Expr`、`Var`、`Number`分别实现`Facotr`接口

* `Term`中有`Factor`的`ArratList`，`Expr`中有`Term`的`ArrayList`

* 在`Term`里实现括号展开的方法——在一个`Process`类里实现了`termMultTerm`、`exorMultiExpr`、`exprMultiNumber`、`exprMultiVar`的方法，调用这些方法后，返回一个`ArrayList<Term>`（弊端很大）

* `Factor`和`Term`都设置符号（弊端很大）

### UML

![uml1](D:\University\Study\2023spring\orientedObjective\Unit_1\images\uml1.jpg)

### 度量数据

`CogC`认知复杂度：是否容易被人类理解，高则**不易理解**。

`ev(G)`意为基本复杂度：衡量程序非结构化程度，高则**非结构化程度高**，**难以模块化和维护**。

`iv(G)`模块设计复杂度：模块和其他模块的调用关系，高则**模块耦合度高**。

`v(G)`圈复杂度：合理的预防错误所需测试的最少路径条数，高则**质量低且难于测试和维护**。

![image1](D:\University\Study\2023spring\orientedObjective\Unit_1\images\image1.png)

此处只截取了红色的数字内容，可以看到Term中的括号展开方法的有三项均高，这个方法调用了很多乘法方法，导致耦合度很高，确实对程序造成了很大影响。

``preProcess``是预处理输入表达式的方法，也是三项均高，但这个方法没有对我造成影响。

### 程序bug

复杂的括号展开加上不合理的符号保存改变，强测和互测中在符号处理方面出现较多bug。

## 第二次作业

### 题目要求

新增三项：

* 多层括号
* 三角函数因子
* 自定义函数（定义时等号右边不可以有自定义函数）

### 遇到的困难

相较于第一次作业，本次遇到的难点较少，进行较顺利。但未进行充分测试，有三处致命bug，强测惨烈。

### 架构设计

* 三角函数：

  新建`sin`、`cos`类实现`Factor`接口。

  只对表达式为0的情况进行了化简。

* 自定义函数的处理：

  课上老师说使用解析法饭后相应的项或因子，而不要在字符串层面进行处理。

  但我还是在字符串层面进行处理，先将输入的表达式中的自定义函数全部展开，然后再进行表达式解析。

  为此我新建了一个`Diy`类和一个`ExpandDiy`类：

  1. `Diy`类来保存每个自定义函数的格式，包括有几个参数，每个参数都是什么。

  2. `ExpandDiy`类用于展开表达式中的自定义函数，具体方法为其内有两个方法，`diyExpanded`和`expand`：
     * `diyExpanded`创建并返回表达式中的所有自定义函数展开结果：若读到f、g、h时跳入`expand`方法并传入函数名参数，`expand`返回一个字符串，加入`diyExpanded`的字符串中；否则直接将字符加`diyExpanded`入字符串中。
     * `expand`方法根据函数名新建相应的自定义函数实例，根据逗号分隔参数（自定义函数的实参中有其他自定义函数，则进入递归调用`expand`，返回相应的表达式字符串。），并改变自定义函数实例的参数。最后返回这个自定义函数的表达式字符串。

* 括号展开及符号保存的修改

  因为第一次作业再此处吃了大亏，所以进行了较大改动：

  * 括号展开使用递归方法，并最终返回类型为Expr。具体步骤：
    1. 新建``expr``，遍历``HashMap``，存在``factor``是``Expr``，则：
       1. 遍历``expr``的``terms``，将**term中的每个factor**和**Term中的其除expr外的factor**拼在一起生成一个新``term``，再对这个新term进行括号展开。
       2. 得到一个新``expr``，将其``terms``中的所有``term``中加入``expr``中的``terms``中。
       3. ``break``
    2. 如果``HashMap``中不存在Expr，直接返回一个只包含这一个term的expr（注意要对term进行深拷贝，即向一个新term中装入每个factor）

  * Factor保存符号，Term不再有符号。

  * Term中使用``HashMap``<Factor, Integer>存储除number外的，key是Factor，value是Factor的指数。这样的好处在于：添加除expr的Factor时，只需改变```HashMap``中对应的Factor的value即可实现初步化简。
  * Term属性增加系数和系数的符号，在加入number时改变这两项即可。

* Expr类中新增merge方法，对表达式进行化简。

### UML

![uml2](D:\University\Study\2023spring\orientedObjective\Unit_1\images\uml2.jpg)

### 度量数据

![image2](D:\University\Study\2023spring\orientedObjective\Unit_1\images\image2.png)

随着增量开发，复杂度大幅升高。

### 程序bug

有三个主要bug：

* 指数为0是将其视作常数1并带符号
* 类似`f(x)=x**2` `f(sin(x)**2)`，展开后表达式为`sin(x)**2**2`就不能解析了
* 要将输入“规范化”

## 第三次作业

### 题目要求

新增三项：

* 求导（`dx`、`dy`、`dz`）
* 自定义函数（定义时等号右边可以有**已经定义**的自定义函数）

### 遇到的困难

* 定义时等号右边有已经定义的自定义函数这一点容易解决，但可能存在求导。（但由于丢三落四的操作产生了许多bug，导致强测错了很多）

### 架构设计

* 确定自定义函数等号右侧表达式：

  对等号右边先进行自定义函数展开，在进行一次递归下降解析，得到的`expr`调用`toString`后赋给改自定义函数。

* 在`Term`中新增求导方法：

  根据乘法法则求导，返回一个`expr`。

* 在`Expr`中新增求导方法：

​		对`terms`中各个`term`求导。

* 在`Paser`中新增读到`dx`、`dy`、`dz`的操作：

​		进入`paserExpr`，并将得到的`expr`求导，得到求导后的`expr`。

### UML

![uml3](D:\University\Study\2023spring\orientedObjective\Unit_1\images\uml3.jpg)

### 度量数据

![image3](D:\University\Study\2023spring\orientedObjective\Unit_1\images\image3.png)

迭代后产生了更高的复杂度，还是对各个方法的理解不到位，方法写的复杂、耦合度高。

### 程序bug

有四个bug：

* 判断expr相等：

  我的判断expr相等的方法是判断其中的每个term都相等，而判断term相等的方法在最初是用来合并term时使用的，term的factors相等即可合并，所以满足这个条件是即判定两个term相等。沿用这个方法**忽视了term的系数**，所以出错了。

  这个bug会影响三角函数相等的判定，在第二次作业时就存在，但第二次作业并没有检查出来。本次涉及三角函数求导，加大了bug出现的可能，所以本次作业中暴露出了这个问题。

* 三角函数求导后符号判定：

  term的表达式为：$$a×x^b×y^c×z^d×sin(expr)^d×cos(expr)^e$$
  
  比如对进行到对cos求导，新term的系数符号应该是**term的系数符号**乘**cos的符号**乘-1，而我忘记了乘cos的符号，导致符号错误。
  
* 对自定义函数的解析

  因为本次作业自定义函数等号右侧可能有求导，所以我先将等号右边的部分用递归下降解析法展开，在给到自定义函数。预处理时，等号右边的部分与正常表达式解析应该是一样的，但我**没有将`^+`变成`^`**，导致出现了如`^+2`的情况。强测数据大多数是因为这一点WA的。
  
* -dx(x)的错误

  parser中读到`dx`、`dy`、`dz`则进入`paserExpr`，再将得到`expr`求导，后把负号赋给`expr`，我忘记给`expr`赋负号了，实在不应该。
  
  ## 心得体会
  
  ​		第一单元结束了，结果并不理想。

  ​		第一次作业做的很艰辛，原因是对题目所需知识理解得不到位，缺乏举一反三的能力，也不知道各个类应该具备什么属性、什么功能，导致做得很慢，架构也不好。

  ​		第二次和第三次作业虽然做的较为轻松，但强测得分很低，可能受到第一次作业影响，过了公测就不想再做OO了，没进行进一步自测，导致强测得分很低很低。

  ​		我的bug中有许多“忘记”导致的、也有许多符号方面的错误，我认为一方面原因是如老师说的，“如果架构好，就不会出现这些容易错的点”；另一方面原因是缺乏测试。

  ​		其实每次作业的任务应该是分为两个环节——编写程序与测试。不能因为程序过了初步测试就不进行测试了，缺少一个环节必然会导致强测互测中不好的结果。
  
  ​		自我测试一方面可以增强自己对程序的理解，另一方面也有助于加强自己的debug能力，这两点在未来的职业发展中也是极为重要的。以后的作业中，编写完程序后还要“多测测”自己的程序，才能保证程序更高的正确性。
  
  ​		同时我并没有重视互测环节，只是随便造了几个数据，随便“刀了刀”。这也是不对的。阅读他人代码，寻找他人漏洞，这也是自我提升的环节，要重视起来。
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  