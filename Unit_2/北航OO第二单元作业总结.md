# 第二单元总结

本单元的任务是使用多线程技术，模拟一个多线程实时电梯系统，并通过迭代增添新的功能。多线程技术涉及同步块、锁等概念，这二者是之前从未接触过的。通过三周的学习，对多线程相关技术有了进一步理解。

## 同步块与锁

**同步块**：可以被多个线程访问的”东西“。这个”东西“可以是一个类、一个对象实例等等。

多个线程有可能对同步块进行同时访问，包括修改、获取信息等等。由于线程运行的不确定性，我们无法知道获取到的信息是否准确，这会影响线程的执行。（试想，A线程要修改信息，B线程要获取信息，但A和B的先后顺序是不确定的，A修改前后的信息都有可能被B获得）于是，引入了锁。

**锁**：给同步块设置”只能由一个（若干个）线程访问“的限制。当一个（若干个）线程对同步块进行访问时，其他线程会进入等待状态。直到访问的线程结束访问，其他线程才能访问同步块。这就如同将”同步块“视作一个”房间“，”线程“视作”要进入房间的人“。人进入房间后，会将房间门锁住，出来时释放锁，其他人才能进入房间。这便是”锁“的概念。

Java中锁可以由synchronized标识，lock类等方法实现。在我的实现中，并未使用可重入复写锁等。所以我都是用用synchronized实现锁的。

## 生产者消费者模式

通过一个场景来引入这个模式：

厨师和顾客之间有一个托盘，厨师往托盘里放食物，顾客从托盘里取食物。这个场景中，厨师、顾客被我们视作两个线程，托盘则是同步块。很明显，厨师和顾客这两个”线程“都可以对托盘这个”同步块“进行访问。当托盘是空的时候，顾客就不能拿。（若托盘存在容量上限，达到上限时厨师也不能放）由此，我们引入了wait()机制，即在某些情况下，线程要等待。

wait()的原理可以概括为，A进程已经拿到了锁，进入方法后发现“托盘是空的”时，A进程就进行wait()并释放锁，当B线程获取锁后，B线程在执行过程中发出notify()后释放锁，A进程收到notify信号，继续执行（若不止一个线程在wait()，则它们之间又会进行竞争）。

一个简单例子如代码所示：

```java
Class Consumer() implement Runnable{
    private Plate plate;
    public Consumer(Plate plate) {
        this.plate = palte;
    }
    public void run() {
        while (true) {
        	this.plate.getFood();    
        }
    }
}

Class Cook() implement Runnable {
    private Plate plate;
    public Cook(Plate plate) {
        this.plate = plate;
    }
    public void run() {
        while (true) {
        	this.plate.putFood();    
        }
    }
}

Class Plate() {
    private int foodCount;
    public Plate() {
        this.foodCount = 0;
    }
    public synchronized void getFood() {
        if (this.foodCount <= 0) {
            try {
                this.wait();
            } catch (InterruptedException e) {
                throw new RuntimeException(e);
            }
        }
        this.foodCount--;
        notifyAll();
    }
    public synchronized void putFood() {
        this.foodCount++;
        notifyAll();
    }
}

public static void main() {
    Plate plate = new Plate();
    Consumer consumer = new Consumer(plate);
    Cook cook = new Cook(plate);
    new Thread(consumer).start();
    new Thread(cook).start();
}

```

在本单元作业中，输入类，调度器类，电梯类三者之间均存在生产者消费者模式，将在下文一一详细论述。

## ALS策略

课程组要求不能只用一部电梯或把任务随机分配给电梯，这样的电梯效率是低下的~~有时其实也挺快的~~，不能满足评测时间要求。所以电梯至少要满足捎带策略——本单元作业标程采用的基准策略——ALS策略。引入官方说明并加以解析：

对于每一个电梯，都采用 ALS 策略，即新增**主请求**和**被捎带请求**两个概念

- 主请求选择规则：
  - 如果电梯中没有乘客，将请求队列中到达时间最早的请求作为主请求（主请求其实只起到了决定电梯运行方向的作用）
  - 如果电梯中有乘客，将其中到达时间最早的乘客请求作为主请求
- 被捎带请求选择规则：
  - 电梯的主请求存在
  - 该请求投喂的时刻**小于等于**电梯到达该请求出发楼层关门的截止时间（这一条容易让人误以为是上帝视角，知道每个请求来到的时间。实际上就是什么情况下电梯可以把人带上：比如电梯上行，还没到6楼时，6楼有人要上楼。）
  - 电梯的运行方向和该请求的目标方向一致
- 在电梯的调度上，采用一种较为均衡的调度方式，例如 77 层有5个乘客，那么第1个乘客分配给第1部电梯，第2个乘客分配给第2部电梯，第3个乘客分配给第3部电梯，第4个乘客分配给第1部电梯，第5个乘客分配给第2部电梯。（这一条很重要，很多情况下比其他调度策略都重要）
- 在电梯维护上，接收到维护指令的电梯会在接收到`MAINTAIN`指令后停靠在最近的楼层并立刻放出所有乘客。（第六次作业增添，将在HW6中详细论述）
- 对无法使用一部电梯完成的请求采用静态调度策略，即事先规划好完成该请求时需要乘坐的电梯顺序，然后按照该顺序乘坐电梯，当这些电梯中有的电梯在还未乘上便进入维护时则重新规划。标程在规划时会选择乘坐电梯数最少的方案。（第七次作业增添，将在HW7中详细论述）

因为官方的描述注重抽象，而我的更容易理解比较具象的概念。所以开始做本单元作业时，花了好久来理解ALS策略。将这几条要求具象化，对于解决电梯调度问题是很有帮助的。

## HW5

### 分析

本次作业要求是固定6部电梯，固定速度，使用上述捎带策略。初始多线程，首先考虑那些对象实例需要单开线程——6部电梯类``Elevator``，输入类``InputThread``，调度器类``Schedule``。还有其他的线程设计方法，如调度器不单开线程等等。我的方法在三次作业中没有改变过，适应性较好。

我使用的是流水线架构，即在主线程创建输入线程、调度器线程、6个电梯线程。输入线程向总队列``RequestQueue``里添加请求，调度器``Schedule``取走请求并将其放入某部电梯内部队列里，电梯``Elevator``根据内部队列``RequestQueue``、外部队列``RequestQueue``确定移动方向并进行状态转换。

其实流水线架构可以理解为两个生产者消费者模式，一个是**输入线程-总队列-调度器**，另一个是**调度器-电梯外部队列-电梯**。输入线程和调度往总队列里增加请求的方式、调度器和电梯获取请求的方式应该是一样的。

在电梯状态转换方面，我的设计是在五个State中不断切换，在opreate()方法中根据不同状态调用相应的方法，并把operate()方法放在继承方法run()中。

思考ALS调度策略，发现主请求的作用只是**决定电梯的移动方向**。如果主请求在电梯的外部队列，则将其``from``作为方向；如果在电梯的内部队列，则将其``to``作为方向。在到达某一楼层时，根据内外部队列判断是否需要进出乘客，进而将依次状态转换为``OPEN`` ``INOUT`` ``CLOSE``；否则继续``MOVE``。

程序结束：实验代码揭示了程序停止是一个“链”：输入文件结束了，输入线程读到结束标志后就结束线程，并将总队列的isEnd设置为true；调度器识别到总队列的isEnd且总队列请求为空时，结束线程并设置各个电梯的外部队列的isEnd为true；最后电梯识别到外部队列的isEnd且内外部队列请求为空时，结束线程。

```java
public void operate() {
	while (true) {
		if (State A) {
			a();
			this.state = B;
		} else if (State B) {
			b();
			this.State = C;
		}
		...
	}
}
```

### 调度器策略方面：

调度器从总队列里取到请求后，综合分析各个电梯此刻的状态，判断能否进行捎带、哪部电梯进行捎带效率更好等、不能捎带则”均衡“分配等等，将请求放到电梯的外部队列中。结合上面的捎带原则，就可以满足本次的时间、电量指标了。

### UML图

![5](D:\University\Study\2023spring\orientedObjective\Unit_2\images\5.png)

## HW6

### 分析

本次作业要求实现维护功能和增加电梯功能：维护功能要求在维护请求发出后，电梯在移动两层内停下来，并放出电梯内部的乘客。增加电梯具有各自的移动时间、id等等。

本次任务想起来很容易，电梯内部设置一个``maintain``标识，当调度器收到维护请求时，将电梯的``maintian``标识设置为``true``；电梯停止，将外部队列直接放回总请求队列，将内部队列`from`修改后放回总请求队列。增加电梯就更容易了，每部电梯增加移动时间等属性，调度器电梯容器中增加新电梯即可。

但实际上实现维护功能有一些麻烦的地方要处理：

* 电梯在哪个状态下响应``maintain``标识，停止并放人
* 程序运行的停止条件是什么

在经历了多次尝试并最终考虑到两层移动的宽松限制，我设计为电梯在仅``ARRIVE``和``FIND``状态对应的方法中响应`maintain`标识，执行`maintain()`方法，线程停止。

由于当请求线程结束后，还会因为电梯维护而向请求队列中增添请求。所以hw5中“一条链”的程序结束方法行不通了。在总队列中设置`cnt`，当调度器收到维护请求时将cnt加一，电梯执行`maintain()`结束时再将其减一。总队列的结束条件就变成了``cnt == 0 && isEnd``。（小组研讨课上，学习到这里可以扩展为收到新的乘客请求就加一，乘客到达目的地后再减一，对于第七次作业的结束判断是有帮助的）

### 调度器策略方面

请求的分配方式与hw5相同，只是在选电梯时不考虑因维修而结束的电梯和`maintain`标识为`true`的电梯。

### UML图

![6](D:\University\Study\2023spring\orientedObjective\Unit_2\images\6.png)

## HW7

### 分析

相对hw6，本次作业增加了同一楼层开门电梯数量的限制以及电梯到达楼层的限制。

同一楼层开门电梯数量的限制的处理较为简单，课程组介绍了资源量Semaphore类，来实现对楼层停靠电梯数量进行限制。原理我认为就是设置信号量，当超出信号量时进行wait()。 这里我自己写了一个Floors类实现了这一类似功能。

```java
Class Floors {
	private final int[] floors;
    public Floors() {
        this.floors = new int[12];
    }
    public synchronized addElevator(int floor) {
        while (this.floors[floor] > 4) {
            wait();
        }
        this.floors[floor]++;
        notifyAll;
    }
}
```

电梯到达楼层的限制就设计到换成问题，试想下述情况：

只有两部电梯，电梯A的停靠楼层是1到5楼，电梯B的停靠楼层是4到10楼。一个请求时从1楼到10楼，那么他要乘坐A到4楼后，换乘B到10楼。

大多数同学采用dfs搜索一条路径（乘坐电梯的顺序），然后乘坐第一个电梯到达非目的楼层后重复该过程，直到到达目的楼层。

我没有采用该方法，**基于本次作业的数据限制**：任意时刻，**电梯系统保证能完成任意请求**，即对于任意请求，总能找出一个楼层序列，序列开头为起点层，结尾为终点层，乘客能够通过使用电梯系统依次经过序列中各楼层直到到达终点层。

所以我使用了更加简单的方法：

乘客`Person`类继承乘客请求类，新增`needBack`属性。

1. 对于一个新请求，调度器首先在**能去接他**的电梯中，根据原有的策略，将其分配至某部电梯。

   * 如果该电梯不能将其送至目标楼层：意味着在未来还要将其返回总队列，将乘客`needBack`设置为`true`，并总队列`cnt`加一。
   * 如果该电梯能将其送至目标楼层：（若乘客`needBack == true`，总队列`cnt`减一）将乘客`needBack`设置为`false`。

2. 该请求进入电梯后，在电梯**到达每个楼层时**进行如下判断：

   * 若电梯上行，当电梯**下一个能到达楼层不是请求目的楼层**且**大于请求目的楼层**，则开门放人。

   * 若电梯下行，当电梯**下一个能到达楼层不是请求目的楼层**且**小于请求目的楼层**，则开门放人。

### 调度器策略方面

在原有策略上，将其乘客分配给能接其的电梯。

### UML图

![7](D:\University\Study\2023spring\orientedObjective\Unit_2\images\7.png)

## bug与debug

hw5：电梯类获取请求时，当外部队列为空时没有执行wait()，CPU超时。

hw6：增添功能时，未充分均衡分配原则，运行超时。

hw7：无。

debug：我没有遇到死锁问题。在调度器分配请求给电梯时、线程停止时输出日志，便于观察。

## 心得体会

第一次接触多线程，了解多线程运行的原理，对线程同步、锁、生产者消费者模式等概念有了进一步理解，初步掌握多线程控制方法。本单元夯实了多线程编程的基础，也见识了多线程的特点以及其带来的bug。同时我也意识到，多线程远远不止于本次作业，还有很多我们没有遇到的难点，没有掌握的方法。在实践中不断提升自己的能力是至关重要的。















